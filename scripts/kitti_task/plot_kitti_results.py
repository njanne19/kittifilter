import numpy as np 
import pandas as pd 
import matplotlib.pyplot as plt 
import os 

# Get the path of the current file 
current_filepath = os.path.dirname(os.path.realpath(__file__))

# Load the predicted and true states
predicted_states = pd.read_csv(os.path.join(current_filepath, "predicted_states.csv"))
true_states = pd.read_csv(os.path.join(current_filepath, "true_states.csv"))

# First plot the states that are generated by the filter (forward, angular velocity) 
plt.figure()
plt.plot(predicted_states["vf"], label="Predicted Forward Velocity")
plt.plot(true_states["vf"], label="True Forward Velocity")
plt.xlabel("Timestep")
plt.ylabel("Forward Velocity (m/s)")
plt.title("Predicted vs True Forward Velocity")
plt.legend() 
plt.grid()

plt.savefig(os.path.join(current_filepath, "predicted_vs_true_vf.png"))

plt.figure()
plt.plot(np.rad2deg(predicted_states["wz"]), label="Predicted Angular Velocity")
plt.plot(np.rad2deg(true_states["wz"]), label="True Angular Velocity")
plt.xlabel("Timestep")
plt.ylabel("Angular Velocity (deg/s)")
plt.title("Predicted vs True Angular Velocity")
plt.legend() 
plt.grid()

plt.savefig(os.path.join(current_filepath, "predicted_vs_true_wz.png"))


# Then, we generate position trajectories for both the true and predicted states. To do this we, 
# we need to integrate the forward and angular velocity to get the x and y positions.

dt = 0.1 # Defined in Kitti 

def calculate_positions(df, dt):
    # Initialize the columns for x, y, and theta with zeros
    df['x'] = 0.0
    df['y'] = 0.0
    df['theta'] = 0.0

    # Initialize the current state
    x, y, theta = 0.0, 0.0, 0.0

    # Iterate through each row in the DataFrame
    for i in range(1, len(df)):
        # Get the forward velocity and angular velocity
        vf = df.loc[i-1, 'vf']
        wz = df.loc[i-1, 'wz']

        # Update theta
        theta += wz * dt
        # Wrap theta to be within -pi to pi
        theta = np.arctan2(np.sin(theta), np.cos(theta))

        # Update x and y
        x += vf * np.cos(theta) * dt
        y += vf * np.sin(theta) * dt

        # Store the updated state in the DataFrame
        df.loc[i, 'x'] = x
        df.loc[i, 'y'] = y
        df.loc[i, 'theta'] = theta

    return df

predicted_states = calculate_positions(predicted_states, dt)
true_states = calculate_positions(true_states, dt) 

# Plot the predicted and true states, x on x axis, y on y axis 
plt.figure()
plt.plot(predicted_states["x"], predicted_states["y"], label="Predicted States")
plt.plot(true_states["x"], true_states["y"], label="True States")
plt.xlabel("x")
plt.ylabel("y")
plt.title("Predicted vs True Trajectories")
plt.legend()
plt.grid()

# Save the plot
plt.savefig(os.path.join(current_filepath, "predicted_vs_true_states.png"))

# Then also create theta vs time plot, fv vs time plot, wz vs time plot 
plt.figure()
plt.plot(np.rad2deg(predicted_states["theta"]), label="Predicted Theta")
plt.plot(np.rad2deg(true_states["theta"]), label="True Theta")
plt.xlabel("Timestep")
plt.ylabel("Theta")
plt.title("Predicted vs True Theta")
plt.legend()
plt.grid()

plt.savefig(os.path.join(current_filepath, "predicted_vs_true_theta.png"))

# Save dataframes back to the OG directories with update values 
predicted_states.to_csv(os.path.join(current_filepath, "predicted_states.csv"), index=False)
true_states.to_csv(os.path.join(current_filepath, "true_states.csv"), index=False)


